# -*- coding: utf-8 -*-
"""Project Capstone Cadangan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u6ReYhC9DI_w7fG_PWY1ZGOidXVg9qr8
"""

import tensorflow as tf
from google.colab import drive
import pandas as pd
import os
import random
from IPython.display import Audio
import numpy as np
import librosa
import subprocess
from collections import Counter
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

from google.colab import drive
drive.mount('/content/drive')

# Path ke folder
folder = '/content/drive/Shareddrives/dataset'

# Dapatkan daftar file dalam folder
files = os.listdir(folder)

# Tampilkan semua file dalam folder
print("Semua File di", folder, ":\n")
for file_or_folder in files:
    print(file_or_folder)

# Menghitung jumlah file
jumlah_file = len(files)
print("\nJumlah total file dalam folder:", jumlah_file)

import wave

# Path ke folder "classical"
classical_folder = os.path.join(folder, 'classical')

# Fungsi untuk membuka dan membaca file wav dalam folder
def baca_file_wav(folder):
    for root, dirs, files in os.walk(folder):
        for file in files:
            file_path = os.path.join(root, file)
            if file.endswith('.wav'):  # Cek apakah file berformat .wav
                print(f"Membuka file: {file_path}\n")
                try:
                    with wave.open(file_path, 'rb') as wav_file:
                        # Mendapatkan informasi dasar tentang file wav
                        n_channels = wav_file.getnchannels()
                        sampwidth = wav_file.getsampwidth()
                        framerate = wav_file.getframerate()
                        n_frames = wav_file.getnframes()
                        duration = n_frames / float(framerate)

                        print(f"Number of channels: {n_channels}")
                        print(f"Sample width: {sampwidth} bytes")
                        print(f"Frame rate: {framerate} frames/second")
                        print(f"Number of frames: {n_frames}")
                        print(f"Duration: {duration:.2f} seconds")
                        print("\n")
                except Exception as e:
                    print(f"Error processing {file_path}: {e}")

# Tampilkan file dalam folder "dataset"
print("Membaca file WAV dalam folder dataset:\n")
baca_file_wav(folder)

from IPython.display import Audio

# Path ke file wav yang ingin diputar
file_path = '/content/drive/Shareddrives/dataset/classical/classical.00007.wav'

# Memutar file wav
print(f"Membuka dan memutar file: {file_path}")
Audio(file_path, autoplay=True)

"""#Labelling Data

Labelling berdasarkan BPM (Beat Per Minute), dibagi menjadi 3 klasifikasi (rendah, sedang, tinggi)

rendah : sulit tidur, relaksasi
sedang : kecemasan, penguatan emosi positif
sedang ke tinggi : depresi, motivasi
"""

# Path ke folder yang berisi file audio
folder_path = '/content/drive/Shareddrives/dataset/'

# Mendapatkan daftar folder di dalam folder dataset
folders = [f for f in os.listdir(folder_path) if os.path.isdir(os.path.join(folder_path, f))]

# Menampilkan daftar folder sebagai label data
labels = []
for folder in folders:
    folder_files = os.listdir(os.path.join(folder_path, folder))
    for file in folder_files:
        labels.append(folder)

# Menampilkan label data
print("Label data:")
print(labels)

!pip install pydub

from pydub import AudioSegment
import os
import numpy as np
import librosa

# Klasifikasi genre musik berdasarkan kebutuhan terapi
genre_to_therapy = {
    "classical": ["Sleeplessness", "Relaxation"],
    "metal": ["Depression", "Motivation"],
    "pop": ["Anxiety", "Positive Energy Reinforcement"],
}

# Fungsi untuk menghitung BPM dari file audio
def get_bpm(file_path):
    audio = AudioSegment.from_file(file_path)
    samples = np.array(audio.get_array_of_samples(), dtype=np.float32)
    samples /= np.max(np.abs(samples))  # Normalize to range [-1, 1]
    tempo, _ = librosa.beat.beat_track(y=samples, sr=audio.frame_rate)
    return tempo

# Menentukan klasifikasi terapi berdasarkan genre dan BPM
def determine_therapy_classification(folder, bpm):
    genre = folder.lower()
    if genre in genre_to_therapy:
        therapy_classifications = genre_to_therapy[genre]
        for therapy_classification in therapy_classifications:
            if "relaxation" in therapy_classification.lower() and 30 < bpm <= 170:
                return therapy_classification
            elif "motivation" in therapy_classification.lower() and 60 < bpm <= 200:
                return therapy_classification
            elif "positive energy reinforcement" in therapy_classification.lower() and 50 < bpm <= 180:
                return therapy_classification
            elif "sleeplessness" in therapy_classification.lower() and 30 < bpm <= 130:
                return therapy_classification
            elif "depression" in therapy_classification.lower() and 60 < bpm <= 150:
                return therapy_classification
            elif "anxiety" in therapy_classification.lower() and 50 < bpm <= 140:
                return therapy_classification
    return "Unknown"

# Path ke folder dataset audio
folder_path = "/content/drive/Shareddrives/dataset"  # Ganti dengan path folder yang berisi folder-folder genre
folders = ["classical", "metal", "pop"]  # Daftar folder genre

# Label data
labels = []

for folder in folders:
    folder_path_full = os.path.join(folder_path, folder)
    folder_files = os.listdir(folder_path_full)
    for file in folder_files:
        file_path = os.path.join(folder_path_full, file)
        if file_path.endswith('.wav'):  # Pastikan untuk memproses hanya file audio
            try:
                bpm = get_bpm(file_path)
                therapy_classification = determine_therapy_classification(folder, bpm)
                labels.append((file, therapy_classification))
            except Exception as e:
                print(f"Error processing {file_path}: {e}")

# Menampilkan label data
print("Label data:")
for label in labels:
    print(label)

"""Cek BPM masing-masing file"""

from pydub import AudioSegment
import numpy as np
import librosa
import os

# Klasifikasi genre musik berdasarkan kebutuhan terapi
genre_to_therapy = {
    "classical": ["Sleeplessness", "Relax"],
    "metal": ["Depression", "Motivation"],
    "pop": ["Anxiety", "Positive Energy Reinforcement"],
}

# Fungsi untuk menghitung BPM dan ketukan dari file audio
def get_bpm_and_beats(file_path):
    audio = AudioSegment.from_file(file_path)
    samples = np.array(audio.get_array_of_samples(), dtype=np.float32)
    samples /= np.max(np.abs(samples))  # Normalize to range [-1, 1]
    tempo, beat_frames = librosa.beat.beat_track(y=samples, sr=audio.frame_rate)
    beats = librosa.frames_to_time(beat_frames, sr=audio.frame_rate)
    print(f"File name: {file_path.split('/')[-1]}, BPM: {tempo}")
    return tempo, beats


# Path ke folder dataset audio
folder_path = "/content/drive/Shareddrives/dataset"  # Ganti dengan path folder yang berisi folder-folder genre

for folder in genre_to_therapy:
    folder_path_full = os.path.join(folder_path, folder)
    folder_files = os.listdir(folder_path_full)
    for file in folder_files:
        file_path = os.path.join(folder_path_full, file)
        if file_path.endswith('.wav'):  # Pastikan untuk memproses hanya file audio
            try:
                bpm, beats = get_bpm_and_beats(file_path)
                labels.append((file, genre_to_therapy[folder], bpm, beats))
            except Exception as e:
                print(f"Error processing {file_path}: {e}")

# Klasifikasi genre musik berdasarkan kebutuhan terapi
genre_to_therapy = {
    "classical": ["Sleeplessness", "Relax"],
    "metal": ["Depression", "Motivation"],
    "pop": ["Anxiety", "Positive Energy Reinforcement"],
}

# Fungsi untuk menghitung BPM dan mengekstraksi fitur MFCC
def extract_features_and_bpm(file_paths):
    features = []
    for file_path in file_paths:
        # Memuat file audio
        audio, sr = librosa.load(file_path)
        # Ekstraksi fitur (contoh: 20 koefisien MFCC)
        mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=20)
        # Rata-rata dari setiap koefisien MFCC
        mfccs_mean = np.mean(mfccs, axis=1)

        # Menghitung BPM
        audio_segment = AudioSegment.from_file(file_path)
        samples = np.array(audio_segment.get_array_of_samples(), dtype=np.float32)
        samples /= np.max(np.abs(samples))  # Normalize to range [-1, 1]
        bpm, _ = librosa.beat.beat_track(y=samples, sr=audio_segment.frame_rate)

        # Menggabungkan fitur MFCC dan BPM
        features.append(np.append(mfccs_mean, bpm))
    return np.array(features)

"""# EDA

1. Memeriksa format data
"""

# Path ke folder yang berisi file audio
folder_path = '/content/drive/Shareddrives/dataset'

# Dictionary untuk menyimpan jumlah file untuk setiap tipe format data
format_count = {}

# List folder yang akan kita jelajahi
folders_to_explore = ['classical', 'pop', 'metal']


# Loop melalui semua file dalam folder
for file_name in os.listdir(folder_path):
    # Ambil ekstensi file
    file_ext = os.path.splitext(file_name)[1].lower()
    # Periksa apakah ekstensi file telah ditempatkan dalam dictionary
    if file_ext in format_count:
        # Tambahkan jumlah file untuk ekstensi yang sudah ada
        format_count[file_ext] += 1
    else:
        # Buat entri baru dalam dictionary jika ekstensi belum ada
        format_count[file_ext] = 1

# Menampilkan jumlah file dengan format yang berbeda
print("Jumlah file dengan format:")
for ext, count in format_count.items():
    print(f"{ext}: {count}")

# Loop melalui file dalam folder dan buka file untuk setiap format yang ada
for ext in format_count.keys():
    # Menentukan path folder untuk format file tertentu
    format_folder_path = os.path.join(folder_path, ext.replace('.', ''))
    # Menampilkan nama file dari setiap format
    print(f"\nFile dalam format {ext}:")
    for file_name in os.listdir(format_folder_path):
        print(file_name)

# Menampilkan semua file dalam setiap subfolder
for folder_name in folders_to_explore:
    folder_subpath = os.path.join(folder_path, folder_name)
    print(f"\nFile dalam folder {folder_name}:")
    for file_name in os.listdir(folder_subpath):
        print(file_name)

"""2. Memeriksa jumlah dataset"""

# Dictionary untuk menyimpan jumlah data untuk setiap kelas
class_count = {folder_name: 0 for folder_name in folders_to_explore}

# Loop melalui setiap folder
for folder_name in folders_to_explore:
    folder_subpath = os.path.join(folder_path, folder_name)
    class_count[folder_name] = len(os.listdir(folder_subpath))

# Menampilkan jumlah data untuk setiap kelas
print("Jumlah data untuk setiap kelas:")
for folder_name, count in class_count.items():
    print(f"{folder_name}: {count}")

"""#Pembagian Data menjadi Data Train dan Data Test"""

# Inisialisasi list untuk menampung path file dari setiap kelas
file_paths = []
labels = []

# Loop melalui setiap folder
for folder_name in folders_to_explore:
    folder_subpath = os.path.join(folder_path, folder_name)
    # Mendapatkan path file dari setiap kelas
    class_files = [os.path.join(folder_subpath, file_name) for file_name in os.listdir(folder_subpath)]
    file_paths.extend(class_files)
    labels.extend([folder_name] * len(class_files))  # Menambahkan label untuk setiap file

# Memisahkan data menjadi data latih dan data uji
train_files, test_files, train_labels, test_labels = train_test_split(file_paths, labels, test_size=0.2, random_state=42)

# Path ke folder yang berisi file audio
folder_path = '/content/drive/Shareddrives/dataset'

# List folder yang akan kita jelajahi
folders_to_explore = ['classical', 'pop', 'metal']

# Fungsi untuk mengekstraksi fitur dari file audio (contoh: MFCC)
def extract_features(file_paths):
    features = []
    for file_path in file_paths:
        # Memuat file audio
        audio, sr = librosa.load(file_path)
        # Ekstraksi fitur (contoh: 20 koefisien MFCC)
        mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=20)
        # Rata-rata dari setiap koefisien MFCC
        mfccs_mean = np.mean(mfccs, axis=1)
        features.append(mfccs_mean)
    return np.array(features)

# Membaca file dan mengekstraksi fitur untuk data latih dan data uji
X_train = extract_features_and_bpm(train_files)
X_test = extract_features_and_bpm(test_files)

# Membuat label numerik untuk kelas
class_mapping = {class_name: index for index, class_name in enumerate(folders_to_explore)}
y_train = np.array([class_mapping[label] for label in train_labels])
y_test = np.array([class_mapping[label] for label in test_labels])

# Menampilkan informasi tentang pembagian data
print("Jumlah data latih:", len(train_files))
print("Jumlah data uji:", len(test_files))
print("Ukuran fitur X_train:", X_train.shape)
print("Ukuran fitur X_test:", X_test.shape)
print("Ukuran label y_train:", y_train.shape)
print("Ukuran label y_test:", y_test.shape)

"""Pemodelan menggunakan Dense Neural Network (DNN) atau Feedforward Neural Network/Multilayer Perceptron (MLP)"""

from sklearn.metrics import classification_report

num_classes = len(class_mapping)
input_dim = X_train.shape[1]

# Definisi model dengan metode hybrid
inputs = tf.keras.layers.Input(shape=(input_dim,))
x = tf.keras.layers.Dense(512, activation='relu')(inputs)
x = tf.keras.layers.Dropout(0.5)(x)
x = tf.keras.layers.Dense(256, activation='relu')(x)
x = tf.keras.layers.BatchNormalization()(x)
x = tf.keras.layers.Dropout(0.5)(x)
x = tf.keras.layers.Dense(128, activation='relu')(x)
x = tf.keras.layers.Dropout(0.5)(x)
x = tf.keras.layers.Flatten()(x)
outputs = tf.keras.layers.Dense(num_classes, activation='softmax')(x)

# Inisialisasi model
model = tf.keras.Model(inputs=inputs, outputs=outputs)

# Kompilasi model
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Melatih model
history = model.fit(X_train, y_train, epochs=150, batch_size=32, validation_data=(X_test, y_test))

# Evaluasi model pada data uji
loss, accuracy = model.evaluate(X_test, y_test)
print(f'Test Loss: {loss:.4f}')
print(f'Test Accuracy: {accuracy:.4f}')

# Prediksi pada data uji
y_pred = model.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1)

# Menampilkan laporan klasifikasi
print('\nClassification Report:')
print(classification_report(y_test, y_pred_classes))

from sklearn.metrics import classification_report
import matplotlib.pyplot as plt

# Membuat plot untuk memeriksa overfitting
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 2)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Train and Validation Accuracy Over Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')

plt.show()

"""(Trial) Pemodelan Menggunakan CNN"""

import tensorflow as tf

# Inisialisasi model CNN
model_cnn = tf.keras.Sequential([
    tf.keras.layers.Reshape((X_train.shape[1], 1), input_shape=(X_train.shape[1],)),
    tf.keras.layers.Conv1D(64, 3, activation='relu', padding='same'),
    tf.keras.layers.MaxPooling1D(2),
    tf.keras.layers.Conv1D(128, 3, activation='relu', padding='same'),
    tf.keras.layers.MaxPooling1D(2),
    tf.keras.layers.Conv1D(256, 3, activation='relu', padding='same'),
    tf.keras.layers.GlobalAveragePooling1D(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(num_classes, activation='softmax')
])

# Kompilasi model
model_cnn.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Menampilkan ringkasan model
model_cnn.summary()

# Melatih model CNN
history_cnn = model_cnn.fit(X_train[..., np.newaxis], y_train, epochs=150, batch_size=32, validation_data=(X_test[..., np.newaxis], y_test))

# Evaluasi model pada data uji
loss_cnn, accuracy_cnn = model_cnn.evaluate(X_test[..., np.newaxis], y_test)
print(f'Test Loss (CNN): {loss_cnn:.4f}')
print(f'Test Accuracy (CNN): {accuracy_cnn:.4f}')

"""(Trial) Pemodelan Menggunakan RNN"""

import tensorflow as tf

# Inisialisasi model RNN
model_rnn = tf.keras.Sequential([
    tf.keras.layers.Reshape((X_train.shape[1], 1), input_shape=(X_train.shape[1],)),
    tf.keras.layers.LSTM(64, return_sequences=True),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.LSTM(128),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(num_classes, activation='softmax')
])

# Kompilasi model
model_rnn.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Menampilkan ringkasan model
model_rnn.summary()

# Melatih model RNN
history_rnn = model_rnn.fit(X_train[..., np.newaxis], y_train, epochs=150, batch_size=32, validation_data=(X_test[..., np.newaxis], y_test))

# Evaluasi model pada data uji
loss_rnn, accuracy_rnn = model_rnn.evaluate(X_test[..., np.newaxis], y_test)
print(f'Test Loss (RNN): {loss_rnn:.4f}')
print(f'Test Accuracy (RNN): {accuracy_rnn:.4f}')

"""(Trial) Pemodelan menggunakan model hybrid (CNN-RNN)"""

import tensorflow as tf

# Inisialisasi model hybrid
inputs = tf.keras.layers.Input(shape=(X_train.shape[1],))
x = tf.keras.layers.Reshape((X_train.shape[1], 1), input_shape=(X_train.shape[1],))(inputs)
x = tf.keras.layers.Conv1D(64, 3, activation='relu')(x)
x = tf.keras.layers.MaxPooling1D(pool_size=2)(x)
x = tf.keras.layers.LSTM(64)(x)
x = tf.keras.layers.Dense(128, activation='relu')(x)
outputs = tf.keras.layers.Dense(num_classes, activation='softmax')(x)

# Inisialisasi model
model_hybrid = tf.keras.Model(inputs=inputs, outputs=outputs)

# Kompilasi model
model_hybrid.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Menampilkan ringkasan model
model_hybrid.summary()

# Melatih model hybrid
history_hybrid = model_hybrid.fit(X_train, y_train, epochs=150, batch_size=32, validation_data=(X_test, y_test))

# Evaluasi model pada data uji
loss_hybrid, accuracy_hybrid = model_hybrid.evaluate(X_test, y_test)
print(f'Test Loss (Hybrid): {loss_hybrid:.4f}')
print(f'Test Accuracy (Hybrid): {accuracy_hybrid:.4f}')

"""Model yang terpilih : DNN karena tiap model memiliki akurasi yang kurang lebih sama namun model DNN memiliki loss paling rendah"""

# Menyimpan model dalam format TensorFlow SavedModel
model.save('/content/saved_model/my_model')

!pip install tensorflowjs

!tensorflowjs_converter --input_format=tf_saved_model --output_format=tfjs_graph_model /content/saved_model/my_model /content/tfjs_model

"""# Transfer Learning"""

import tensorflow as tf
import os
import numpy as np
import librosa
from pydub import AudioSegment
from sklearn.metrics import classification_report

# Fungsi untuk mengekstraksi fitur dari file audio (contoh: MFCC)
def extract_features(file_paths):
    features = []
    for file_path in file_paths:
        # Memuat file audio
        audio, sr = librosa.load(file_path)
        # Ekstraksi fitur (contoh: 20 koefisien MFCC)
        mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=20)
        # Rata-rata dari setiap koefisien MFCC
        mfccs_mean = np.mean(mfccs, axis=1)
        features.append(mfccs_mean)
    return np.array(features)

# Fungsi untuk menghitung BPM dari file audio
def get_bpm(file_path):
    audio = AudioSegment.from_file(file_path)
    samples = np.array(audio.get_array_of_samples(), dtype=np.float32)
    samples /= np.max(np.abs(samples))  # Normalize to range [-1, 1]
    tempo, _ = librosa.beat.beat_track(y=samples, sr=audio.frame_rate)
    return tempo

# Klasifikasi genre musik berdasarkan kebutuhan terapi
genre_to_therapy = {
    "classical": ["Sleeplessness", "Relaxation"],
    "metal": ["Depression", "Motivation"],
    "pop": ["Anxiety", "Positive Emotion Reinforcement"],
}

# Menentukan klasifikasi terapi berdasarkan genre dan BPM
def determine_therapy_classification(genre, bpm):
    genre = genre.lower()
    if genre in genre_to_therapy:
        therapy_classifications = genre_to_therapy[genre]
        for therapy_classification in therapy_classifications:
            if "relaxation" in therapy_classification.lower() and 30 < bpm <= 100:
                return therapy_classification
            elif "motivation" in therapy_classification.lower() and 50 < bpm <= 150:
                return therapy_classification
            elif "positive emotion reinforcement" in therapy_classification.lower() and 60 < bpm <= 170:
                return therapy_classification
            elif "sleeplessness" in therapy_classification.lower() and 30 < bpm <= 60:
                return therapy_classification
            elif "depression" in therapy_classification.lower() and 50 < bpm <= 100:
                return therapy_classification
            elif "anxiety" in therapy_classification.lower() and 60 < bpm <= 120:
                return therapy_classification
    return "Unknown"

# Fungsi untuk memprediksi genre dan kebutuhan terapi
def predict_genre_and_therapy(model, file_path):
    # Ekstraksi fitur dari file audio
    features = extract_features([file_path])
    # Prediksi genre menggunakan model
    y_pred = model.predict(features)
    genre_index = np.argmax(y_pred, axis=1)[0]
    genre = list(class_mapping.keys())[genre_index]
    # Hitung BPM
    bpm = get_bpm(file_path)
    # Tentukan kebutuhan terapi
    therapy_classification = determine_therapy_classification(genre, bpm)
    return genre, therapy_classification

# Path ke file audio baru
new_file_path = '/content/drive/Shareddrives/data music app/metal/Metallica - Enter Sandman.wav'

# Prediksi genre dan kebutuhan terapi
predicted_genre, therapy_need = predict_genre_and_therapy(model, new_file_path)
print(f"Predicted Genre: {predicted_genre}")
print(f"Therapy Need: {therapy_need}")

def get_user_input():
    condition = input("Select your condition:\n a. Depression\n b. Anxiety\n c. Sleeplessness\n")
    need = input("Select your therapeutic needs:\n a. Relaxation\n b. Motivation\n c. Positive Emotion Reinforcement\n")
    return condition, need

category_mapping = {
    ('a', 'a'): 'Relax',
    ('a', 'b'): 'Motivation',
    ('a', 'c'): 'Depression',
    ('b', 'a'): 'Relax',
    ('b', 'b'): 'Motivation',
    ('b', 'c'): 'Anxiety',
    ('c', 'a'): 'Sleep',
    ('c', 'b'): 'Motivation',
    ('c', 'c'): 'Positive Energy'
}

def recommend_songs(category, labels, files):
    recommendations = [file for file, label in zip(files, labels) if label == category]
    return recommendations

def main():
    # Mengambil input dari pengguna
    condition, need = get_user_input()

    # Debug statements untuk memeriksa input pengguna
    print(f"User condition: {condition}")
    print(f"User need: {need}")

    # Menentukan kategori berdasarkan input pengguna
    category = category_mapping.get((condition, need), 'Unknown')

    # Debug statement untuk memeriksa kategori yang ditentukan
    print(f"Determined category: {category}")

    if category != 'Unknown':
        # List file audio dan label yang dihasilkan dari ekstraksi fitur sebelumnya
        file_paths = [
            '/content/drive/Shareddrives/data music app/classical/Bach - Air from Orchestral Suite no. 3.wav',
            '/content/drive/Shareddrives/data music app/classical/Peder B Helland - Calm Wind.wav',
            '/content/drive/Shareddrives/data music app/nature/Flowing River & Forest Birds.wav',
            '/content/drive/Shareddrives/data music app/nature/Night Time Forest.wav',
            '/content/drive/Shareddrives/data music app/nature/The Sunrise.wav',
            '/content/drive/Shareddrives/data music app/nature/Birds Chirping.wav',
            '/content/drive/Shareddrives/data music app/nature/Spring Forest.wav',
            '/content/drive/Shareddrives/data music app/nature/Robin & Blackbird Song.wav',
            '/content/drive/Shareddrives/data music app/metal/Striker - Circle of Evil.wav',
            '/content/drive/Shareddrives/data music app/metal/Striker - Deathwish.wav',
            '/content/drive/Shareddrives/data music app/metal/Arch Enemy - The Eagle Flies Alone.wav',
            '/content/drive/Shareddrives/data music app/metal/Slipknot - Psychosocial.wav',
            '/content/drive/Shareddrives/data music app/metal/Metallica - Enter Sandman.wav',
            '/content/drive/Shareddrives/data music app/metal/Lordi - Hard Rock Hallelujah.wav',
            '/content/drive/Shareddrives/data music app/metal/Striker - Full or No Speed.wav',
            '/content/drive/Shareddrives/data music app/metal/Avenged Sevenfold - Hail To The King.wav',
            '/content/drive/Shareddrives/data music app/metal/Steelheart - Shes Gone.wav',
            '/content/drive/Shareddrives/data music app/metal/Bon Jovi - Its My Life.wav',
            '/content/drive/Shareddrives/data music app/metal/Metallica- Turn The Page.wav',
            '/content/drive/Shareddrives/data music app/metal/Avenged Sevenfold - So Far Away.wav',
            '/content/drive/Shareddrives/data music app/pop/Charlie Puth - Attention.wav',
            '/content/drive/Shareddrives/data music app/pop/Justin Timberlake - Cant Stop The Feeling.wav',
            '/content/drive/Shareddrives/data music app/pop/Pharrell Williams - Happy.wav',
            '/content/drive/Shareddrives/data music app/pop/Anne-Marie & James Arthur - Rewrite The Stars.wav',
            '/content/drive/Shareddrives/data music app/pop/ZAYN ft. Sia - Dusk Till Dawn.wav',
            '/content/drive/Shareddrives/data music app/pop/Kelly Clarkson - Stronger (WHat Doesnt Kill You).wav',
            '/content/drive/Shareddrives/data music app/classical/Claude Debussy - Clair De Lune.wav',
            '/content/drive/Shareddrives/data music app/classical/Beethoven - Piano Sonata No. 14 Moonlight Sonata (Adagio Sostenuto).wav',
            '/content/drive/Shareddrives/data music app/classical/Franz Schubert - Ave Maria.wav',
            '/content/drive/Shareddrives/data music app/classical/Pocahontas - The Colors Of The Wind (Instrumen).wav',
            '/content/drive/Shareddrives/data music app/classical/Clint Mansell - Leaving Earth.wav',
            '/content/drive/Shareddrives/data music app/classical/Digital Summer - SXXXOXXXE.wav',
            '/content/drive/Shareddrives/data music app/pop/Adele - Someone Like You.wav',
            '/content/drive/Shareddrives/data music app/pop/Avicii - Wake Me Up.wav',
            '/content/drive/Shareddrives/data music app/pop/Coldplay - Fix You.wav',
            '/content/drive/Shareddrives/data music app/pop/Katy Perry - Firework.wav',
            '/content/drive/Shareddrives/data music app/pop/One Direction - What Makes You Beautiful.wav',
            '/content/drive/Shareddrives/data music app/pop/Meghan Trainor - Better When Im Dancin.wav'
        ]
        labels = [
            'Relax','Relax','Relax','Relax','Relax','Relax','Relax',
            'Motivation','Motivation','Motivation','Motivation','Motivation','Motivation',
            'Depression','Depression',
            'Anxiety','Anxiety','Anxiety',
            'Sleep','Sleep','Sleep','Sleep','Sleep','Sleep',
            'Positive Energy','Positive Energy','Positive Energy','Positive Energy','Positive Energy'
        ]

        # Mendapatkan rekomendasi lagu
        recommended_songs = recommend_songs(category, labels, file_paths)

        # Menampilkan rekomendasi
        print(f"Recommended songs for category '{category}':")
        for song in recommended_songs:
            print(song)
    else:
        print("Unknown category. Please ensure your input is correct.")

# Menjalankan fungsi utama
if __name__ == "__main__":
    main()